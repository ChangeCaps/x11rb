language: rust
dist: bionic # x11rb needs at least libxcb 1.12
jobs:
  fast_finish: true
  include:
    # std::io::IoSlice was stabilised in 1.36.0, but 1.36.0 fails with a weird
    # error enabled by deny(single_use_lifetimes).
    - rust: 1.37.0
      env: CLIPPY_RUSTFMT=no
    - rust: stable
      env: CLIPPY_RUSTFMT=yes
    - rust: beta
      env: CLIPPY_RUSTFMT=no
    - rust: nightly
      env: CLIPPY_RUSTFMT=if_available
    - env: CROSS_TARGET=mips64-unknown-linux-gnuabi64 CLIPPY_RUSTFMT=no
      rust: stable
      services: docker
      sudo: required
  allow_failures:
    - rust: nightly
      env: CLIPPY_RUSTFMT=if_available

addons:
  apt:
    packages:
      - xvfb

before_script:
  # Run the examples as 'integration tests'. For this, there is a special
  # timeout mode where the examples close automatically after some time.
  - |
    run_examples() {
        for example in examples/*.rs; do
            example=${example/examples\//}
            example=${example/.rs/}
            if [ "$example" != tutorial ] ; then
                X11RB_EXAMPLE_TIMEOUT=1 xvfb-run -a cargo run --example "$example" "$@" || exit 1
            fi
        done
    }

  - |
    # Run clippy unless $CLIPPY_RUSTFMT is set to "no". If it is set to
    # "if_available", then this is skipped if clippy is not available. With
    # "yes", unavailability counts as an error.
    run_clippy() {
        if [ "x$CLIPPY_RUSTFMT" != "xno" ]; then
            if [ "x$CLIPPY_RUSTFMT" = "xyes" ]; then
                rustup component add clippy || return 1
            else
                rustup component add clippy || return 0
            fi
            cargo clippy --all --all-targets --all-features -- -D warnings || return 1
        fi
    }

  - |
    # Run rustfmt unless $CLIPPY_RUSTFMT is set to "no". If it is set to
    # "if_available", then this is skipped if clippy is not available. With
    # "yes", unavailability counts as an error.
    run_rustfmt() {
        if [ "x$CLIPPY_RUSTFMT" != "xno" ]; then
            if [ "x$CLIPPY_RUSTFMT" = "xyes" ]; then
                rustup component add rustfmt || return 1
            else
                rustup component add rustfmt || return 0
            fi
            cargo fmt --all -- --check || return 1
        fi
    }
  - |
    # Preparations for testing on a big endian platform
    if [ ! -z "$CROSS_TARGET" ]; then
        rustup target add "$CROSS_TARGET" || return 1
        cargo install cross --force || return 1

        # Replace cargo with a shell function
        cargo() {
            command="$1"
            shift
            echo "Running the following:" cross "$command" --target "$CROSS_TARGET" "$@"
            cross "$command" --target "$CROSS_TARGET" "$@"
        }
        skip_on_cross() {
            echo "Skipping $@"
        }
    else
        skip_on_cross() {
            "$@"
        }
    fi

script:
  # Check the code generator. Output should be identical to the
  # committed version.
  - make
  - if ! git diff --exit-code; then exit 1; fi

  - run_clippy
  - run_rustfmt

  # Build once with just the default features, i.e. without all the extensions
  # to check that this works fine.
  - cargo check --verbose --all-targets

  # Skip XCBConnection on cross (libxcb not available)
  - |
    if [ -z "$CROSS_TARGET" ]; then
        export FEATURES="--all-features"
      else
        export FEATURES="--features all-extensions"
      fi
  - cargo build --verbose --all-targets $FEATURES
  - cargo test --verbose $FEATURES
  - cargo doc --verbose $FEATURES

  # Run the examples as 'integration tests'.
  # Enable the 'all-extensions' feature or Cargo will complain.
  # Enable the 'allow-unsafe-code' feature so XCBConnection is used.
  - skip_on_cross run_examples --all-features

  - cargo build --verbose --all-targets --features all-extensions

  # Run the examples as 'integration tests'. This time using RustConnection.
  - run_examples --features "all-extensions libc"
